import os
import random
import json
import asyncio
from datetime import datetime, date

import discord
from discord.ext import tasks
from discord import app_commands

import spotipy
from spotipy.oauth2 import SpotifyOAuth
from dotenv import load_dotenv

load_dotenv()

# ======================
# PATHS / STATE FILES
# ======================

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

USED_SONGS_FILE = os.path.join(BASE_DIR, "used_songs.json")
CHANNEL_CONFIG_FILE = os.path.join(BASE_DIR, "channel_config.json")
LAST_RUN_FILE = os.path.join(BASE_DIR, "last_run.txt")
SPOTIFY_CACHE_FILE = os.path.join(BASE_DIR, "spotify_token.cache")
SCHEDULED_SONGS_FILE = os.path.join(BASE_DIR, "scheduled_songs.json")
ALLOWED_ROLES_FILE = os.path.join(BASE_DIR, "allowed_roles.json")

# ======================
# CONFIG
# ======================

PLAYLIST_ID = "3jCw4Oamo30wY0HBMZGXPl"
POST_HOUR = 10
POST_MINUTE = 0

# ======================
# DISCORD CLIENT
# ======================

intents = discord.Intents.default()
intents.guilds = True
intents.guild_messages = True
intents.message_content = True

client = discord.Client(intents=intents)
tree = app_commands.CommandTree(client)

# ======================
# SPOTIFY AUTH
# ======================

sp = spotipy.Spotify(
    auth_manager=SpotifyOAuth(
        scope="playlist-read-private playlist-read-collaborative",
        redirect_uri=os.getenv("SPOTIPY_REDIRECT_URI"),
        cache_path=SPOTIFY_CACHE_FILE,
        open_browser=True
    )
)

# ======================
# STATE HELPERS
# ======================

def load_json(path, default):
    if os.path.exists(path):
        try:
            with open(path, "r") as f:
                return json.load(f)
        except json.JSONDecodeError:
            pass
    return default

def save_json(path, data):
    with open(path, "w") as f:
        json.dump(data, f, indent=2)

def load_used_songs():
    return set(load_json(USED_SONGS_FILE, []))

def save_used_songs(data):
    save_json(USED_SONGS_FILE, list(data))

def load_channel_config():
    return load_json(CHANNEL_CONFIG_FILE, {})

def save_channel_config(data):
    save_json(CHANNEL_CONFIG_FILE, data)

def load_last_run():
    if os.path.exists(LAST_RUN_FILE):
        with open(LAST_RUN_FILE, "r") as f:
            return date.fromisoformat(f.read().strip())
    return None

def save_last_run(d):
    with open(LAST_RUN_FILE, "w") as f:
        f.write(d.isoformat())

def load_scheduled_songs():
    return load_json(SCHEDULED_SONGS_FILE, {})

def save_scheduled_songs(data):
    save_json(SCHEDULED_SONGS_FILE, data)

def load_allowed_roles():
    return load_json(ALLOWED_ROLES_FILE, {})

def save_allowed_roles(data):
    save_json(ALLOWED_ROLES_FILE, data)

# ======================
# PERMISSION CHECK
# ======================

def is_allowed(interaction: discord.Interaction) -> bool:
    """Admins always allowed. Otherwise check roles."""
    if interaction.user.guild_permissions.administrator:
        return True

    allowed_roles = load_allowed_roles().get(str(interaction.guild.id), [])
    user_roles = [role.name for role in interaction.user.roles]
    return any(role in allowed_roles for role in user_roles)

# ======================
# SPOTIFY TRACK FETCH
# ======================

def get_all_tracks():
    items = []
    offset = 0

    while True:
        page = sp.playlist_items(
            PLAYLIST_ID,
            offset=offset,
            additional_types=["track"]
        )
        items.extend(page["items"])
        if page["next"] is None:
            break
        offset += len(page["items"])

    return [i["track"] for i in items if i["track"]]

# ======================
# MAIN ACTION
# ======================

async def song_of_the_day():
    channel_config = load_channel_config()
    if not channel_config:
        return

    tracks = get_all_tracks()
    if not tracks:
        return

    used = load_used_songs()
    scheduled = load_scheduled_songs()
    today_key = date.today().isoformat()

    lookup = {t["id"]: t for t in tracks}

    if today_key in scheduled:
        song = lookup.pop(scheduled[today_key], None)
        if song:
            del scheduled[today_key]
            save_scheduled_songs(scheduled)
    else:
        unused = [t for t in tracks if t["id"] not in used]
        if not unused:
            used.clear()
            unused = tracks
        song = random.choice(unused)

    if song is None:
        return

    used.add(song["id"])
    save_used_songs(used)

    embed = discord.Embed(
        title=song["name"],
        url=song["external_urls"]["spotify"],
        description=f"**Artist:** {', '.join(a['name'] for a in song['artists'])}",
        color=discord.Color.blue()
    )
    embed.set_thumbnail(url=song["album"]["images"][0]["url"])
    embed.set_footer(text="Automatically selected â€¢ No repeats")

    today = datetime.now().strftime("%A, %B %d, %Y")

    for guild_id, channel_id in channel_config.items():
        channel = client.get_channel(channel_id)
        if channel:
            await channel.send(
                content=f"ðŸŽ¶ **Abyss's Song of the Day â€” {today}** ðŸŽ¶",
                embed=embed
            )

# ======================
# SCHEDULER LOOP
# ======================

@tasks.loop(seconds=10)
async def scheduler():
    now = datetime.now()
    today = now.date()
    last_run = load_last_run()

    if now.hour == POST_HOUR and now.minute == POST_MINUTE and last_run != today:
        await song_of_the_day()
        save_last_run(today)
        await asyncio.sleep(60)

# ======================
# STATUS CYCLING
# ======================

async def cycle_status():
    await client.wait_until_ready()
    statuses = [
        discord.Game(name="testing till i explode or work"),
        discord.Activity(type=discord.ActivityType.listening, name="listening to todays song"),
        discord.Activity(type=discord.ActivityType.watching, name="watching u :3"),
    ]
    i = 0
    while not client.is_closed():
        await client.change_presence(status=discord.Status.online, activity=statuses[i])
        i = (i + 1) % len(statuses)
        await asyncio.sleep(15)

# ======================
# SLASH COMMANDS
# ======================

# --- Set channel ---
@tree.command(name="setchannel")
async def setchannel(interaction: discord.Interaction, channel: discord.TextChannel):
    if not is_allowed(interaction):
        await interaction.response.send_message("You do not have permission.", ephemeral=True)
        return

    config = load_channel_config()
    config[str(interaction.guild.id)] = channel.id
    save_channel_config(config)

    await interaction.response.send_message(
        f"Song of the Day channel set to {channel.mention}",
        ephemeral=True
    )

# --- Schedule a song ---
@tree.command(name="schedule_song")
async def schedule_song(interaction: discord.Interaction, date_str: str, spotify_url: str):
    if not is_allowed(interaction):
        await interaction.response.send_message("You do not have permission.", ephemeral=True)
        return

    try:
        target = date.fromisoformat(date_str)
    except ValueError:
        await interaction.response.send_message("Invalid date format (YYYY-MM-DD).", ephemeral=True)
        return

    if "/track/" not in spotify_url:
        await interaction.response.send_message("Invalid Spotify track URL.", ephemeral=True)
        return

    track_id = spotify_url.split("/track/")[1].split("?")[0]
    scheduled = load_scheduled_songs()
    scheduled[target.isoformat()] = track_id
    save_scheduled_songs(scheduled)

    await interaction.response.send_message("Song scheduled.", ephemeral=True)

# --- Unschedule ---
@tree.command(name="unschedule_song")
async def unschedule_song(interaction: discord.Interaction, date_str: str):
    if not is_allowed(interaction):
        await interaction.response.send_message("You do not have permission.", ephemeral=True)
        return

    scheduled = load_scheduled_songs()
    if date_str not in scheduled:
        await interaction.response.send_message("Nothing scheduled for that date.", ephemeral=True)
        return

    del scheduled[date_str]
    save_scheduled_songs(scheduled)
    await interaction.response.send_message("Schedule removed.", ephemeral=True)

# --- View schedule ---
@tree.command(name="view_schedule")
async def view_schedule(interaction: discord.Interaction, page: int = 1):
    if not is_allowed(interaction):
        await interaction.response.send_message("You do not have permission.", ephemeral=True)
        return

    scheduled = sorted(load_scheduled_songs().items())
    if not scheduled:
        await interaction.response.send_message("No scheduled songs.", ephemeral=True)
        return

    per_page = 10
    total_pages = (len(scheduled) - 1) // per_page + 1
    page = max(1, min(page, total_pages))

    start = (page - 1) * per_page
    end = start + per_page

    lines = [
        f"**{d}** â†’ https://open.spotify.com/track/{t}"
        for d, t in scheduled[start:end]
    ]

    await interaction.response.send_message(
        f"ðŸ“… **Scheduled Songs (Page {page}/{total_pages})**\n\n" + "\n".join(lines),
        ephemeral=True
    )

# --- Clear schedule ---
@tree.command(name="clear_schedule")
async def clear_schedule(interaction: discord.Interaction):
    if not is_allowed(interaction):
        await interaction.response.send_message("You do not have permission.", ephemeral=True)
        return

    save_scheduled_songs({})
    await interaction.response.send_message("All scheduled songs cleared.", ephemeral=True)

# --- Multi-role management via comma-separated role names ---
@tree.command(name="set_allowed_roles")
@app_commands.describe(roles="Enter role names separated by commas")
async def set_allowed_roles(interaction: discord.Interaction, roles: str):
    """Set which roles in this server can use bot commands."""
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("Permission denied.", ephemeral=True)
        return

    role_names = [r.strip() for r in roles.split(",") if r.strip()]
    allowed = load_allowed_roles()
    allowed[str(interaction.guild.id)] = role_names
    save_allowed_roles(allowed)

    await interaction.response.send_message(
        f"Allowed roles set to: {', '.join(role_names)}", ephemeral=True
    )

@tree.command(name="view_allowed_roles")
async def view_allowed_roles(interaction: discord.Interaction):
    allowed = load_allowed_roles().get(str(interaction.guild.id), [])
    if not allowed:
        await interaction.response.send_message("No roles are allowed yet.", ephemeral=True)
        return
    await interaction.response.send_message(f"Allowed roles: {', '.join(allowed)}", ephemeral=True)

@tree.command(name="clear_allowed_roles")
async def clear_allowed_roles(interaction: discord.Interaction):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("Permission denied.", ephemeral=True)
        return

    allowed = load_allowed_roles()
    if str(interaction.guild.id) in allowed:
        del allowed[str(interaction.guild.id)]
        save_allowed_roles(allowed)

    await interaction.response.send_message("Allowed roles cleared.", ephemeral=True)

# ======================
# EVENTS
# ======================

@client.event
async def on_ready():
    print(f"Logged in as {client.user}")
    await tree.sync()
    print("Slash commands synced.")

    # Start scheduler
    scheduler.start()

    # Start cycling statuses
    asyncio.create_task(cycle_status())

# ======================
# RUN
# ======================

client.run(os.getenv("DISCORD_BOT_TOKEN"))
